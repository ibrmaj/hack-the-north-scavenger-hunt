#SXlCVFNFOVFVRmtnUTJsd2FHVnlDZ29qSUZOb2IzQndlU0J1WldWa2N5QjBieUJuWlc1bGNtRjBaU0IxYm1seGRXVWdaR2x6WTI5MWJuUWdZMjlrWlhNZ1ptOXlJSEJ5YjJSMVkzUnpJR0YwSUhSb1pTQnRaWEpqYUdGdWRDQm5kV2xzWkNkeklHSmhlbUZoY2k0Z0NpTWdVMmx1WTJVZ2RHaGxJR2QxYVd4a0ozTWdjbVZqYjNKa0xXdGxaWEJwYm1jZ2MzbHpkR1Z0SUdseklHRnVZMmxsYm5Rc0lIUm9aWGtnWTJGdUozUWdjM1J2Y21VZ2RHaHZkWE5oYm1SeklHOW1JR1JwYzJOdmRXNTBJR052WkdWekxpQUtJeUJKYm5OMFpXRmtMQ0JUYUc5d2NIa2dhR0Z6SUdsdWRtVnVkR1ZrSUhSb1pTQXFLbE5JVDFCUVdTQkRhWEJvWlhJcUtpQXRJR0VnWkdWMFpYSnRhVzVwYzNScFl5QmhiR2R2Y21sMGFHMGdkR2hoZENCaGJIZGhlWE1nY0hKdlpIVmpaWE1nZEdobElITmhiV1VnWkdselkyOTFiblFnWTI5a1pTQm1iM0lnWVNCbmFYWmxiaUJ3Y205a2RXTjBJUW9LWkdWbUlHZGxibVZ5WVhSbFgyTnZaR1VvY0hKdlpIVmpkRjlwWkNrNkNpQWdJQ0FpSWlJS0lDQWdJRWRsYm1WeVlYUmxJR0VnWkdselkyOTFiblFnWTI5a1pTQjFjMmx1WnlCMGFHVWdVMGhQVUZCWklFTnBjR2hsY2k0S0lDQWdJQW9nSUNBZ1FYSm5jem9LSUNBZ0lDQWdJQ0J3Y205a2RXTjBYMmxrT2lCQklIQnZjMmwwYVhabElHbHVkR1ZuWlhJS0lDQWdJQW9nSUNBZ1VtVjBkWEp1Y3pvS0lDQWdJQ0FnSUNCQklITjBjbWx1WnlCcGJpQm1iM0p0WVhRZ0lsTkJWa1V0V0ZoWVdDSWdkMmhsY21VZ1dGaFlXQ0IxYzJWeklHOXViSGtnWVd4c2IzZGxaQ0JqYUdGeVlXTjBaWEp6Q2lBZ0lDQWlJaUlLSUNBZ0lDTWdVM1JsY0NBeE9pQkZXRkJCVGtRZ0xTQkRiMjUyWlhKMElIUnZJSE4wY21sdVp5QmhibVFnY0dGa0lIZHBkR2dnYkdWaFpHbHVaeUI2WlhKdmN5QjBieUJoZENCc1pXRnpkQ0EwSUdScFoybDBjd29nSUNBZ1pYaHdZVzVrWldRZ1BTQnpkSElvY0hKdlpIVmpkRjlwWkNrdWVtWnBiR3dvTkNrS0lDQWdJQW9nSUNBZ0l5QlRkR1Z3SURJNklFTklUMUFnSmlCU1QxUkJWRVVLSUNBZ0lHTm9iM0J3WldSZllXNWtYM0p2ZEdGMFpXUWdQU0JmWTJodmNDaGxlSEJoYm1SbFpDa0tJQ0FnSUhKdmRHRjBaV1FnUFNCZmNtOTBZWFJsS0dOb2IzQndaV1JmWVc1a1gzSnZkR0YwWldRcENpQWdJQ0FLSUNBZ0lDTWdVM1JsY0NBek9pQkZUa05JUVU1VUlDMGdXRTlTSUhkcGRHZ2dVMmh2Y0dsbWVTZHpJR2R5WldWdUlHaGxlQ0JpZVhSbGN3b2dJQ0FnWlc1amFHRnVkR1ZrSUQwZ1gyVnVZMmhoYm5Rb2NtOTBZWFJsWkNrS0lDQWdJQW9nSUNBZ0l5QlRkR1Z3SURRNklFVk9RMDlFUlNBdElFMWhjQ0IwYnlCaGJHeHZkMlZrSUdOb1lYSmhZM1JsY2lCelpYUUtJQ0FnSUdacGJtRnNYMk52WkdVZ1BTQmZaVzVqYjJSbFgzUnZYMkZzYkc5M1pXUmZZMmhoY25Nb1pXNWphR0Z1ZEdWa0tRb2dJQ0FnQ2lBZ0lDQnlaWFIxY200Z1ppSlRRVlpGTFh0bWFXNWhiRjlqYjJSbGZTSUtDbVJsWmlCZlkyaHZjQ2h3Y205a2RXTjBYMmxrS1RvS0lDQWdJQ01nVTNCc2FYUWdhVzUwYnlBeUxXTm9ZWEpoWTNSbGNpQmphSFZ1YTNNS0lDQWdJR05vZFc1cmN5QTlJRnR3Y205a2RXTjBYMmxrVzJrNmFTc3lYU0JtYjNJZ2FTQnBiaUJ5WVc1blpTZ3dMQ0JzWlc0b2NISnZaSFZqZEY5cFpDa3NJRElwWFFvZ0lDQWdjbVYwZFhKdUlHTm9kVzVyY3dvS0NtUmxaaUJmY205MFlYUmxLR05vZFc1cmN5azZDaUFnSUNBaklGSnZkR0YwWlNCbFlXTm9JR05vZFc1cklHSjVJR2wwY3lCd2IzTnBkR2x2YmlBb01TMXBibVJsZUdWa0tRb2dJQ0FnY205MFlYUmxaRjlqYUhWdWEzTWdQU0JiWFFvZ0lDQWdabTl5SUhCdmMybDBhVzl1TENCamFIVnVheUJwYmlCbGJuVnRaWEpoZEdVb1kyaDFibXR6TENBeEtUb0tJQ0FnSUNBZ0lDQnliM1JoZEdsdmJsOWhiVzkxYm5RZ1BTQndiM05wZEdsdmJpQWxJR3hsYmloamFIVnVheWtLSUNBZ0lDQWdJQ0J5YjNSaGRHVmtJRDBnWTJoMWJtdGJMWEp2ZEdGMGFXOXVYMkZ0YjNWdWREcGRJQ3NnWTJoMWJtdGJPaTF5YjNSaGRHbHZibDloYlc5MWJuUmRJR2xtSUhKdmRHRjBhVzl1WDJGdGIzVnVkQ0JsYkhObElHTm9kVzVyQ2lBZ0lDQWdJQ0FnY205MFlYUmxaRjlqYUhWdWEzTXVZWEJ3Wlc1a0tISnZkR0YwWldRcENpQWdJQ0FLSUNBZ0lISmxkSFZ5YmlBbkp5NXFiMmx1S0hKdmRHRjBaV1JmWTJoMWJtdHpLUW9LQ21SbFppQmZaVzVqYUdGdWRDaDBaWGgwS1RvS0lDQWdJQ01nV0U5U0lHVmhZMmdnWTJoaGNtRmpkR1Z5SUhkcGRHZ2dVMmh2Y0dsbWVTZHpJR2R5WldWdUlHaGxlQ0JpZVhSbGN6b2dNSGc1Tml3Z01IaENSaXdnTUhnME9Bb2dJQ0FnYzJodmNHbG1lVjluY21WbGJsOWllWFJsY3lBOUlGc3dlRGsyTENBd2VFSkdMQ0F3ZURRNFhRb2dJQ0FnWlc1amFHRnVkR1ZrWDJKNWRHVnpJRDBnVzEwS0lDQWdJQW9nSUNBZ1ptOXlJR2tzSUdOb1lYSWdhVzRnWlc1MWJXVnlZWFJsS0hSbGVIUXBPZ29nSUNBZ0lDQWdJR0o1ZEdWZmRtRnNkV1VnUFNCdmNtUW9ZMmhoY2lrS0lDQWdJQ0FnSUNCbmNtVmxibDlpZVhSbElEMGdjMmh2Y0dsbWVWOW5jbVZsYmw5aWVYUmxjMXRwSUNVZ2JHVnVLSE5vYjNCcFpubGZaM0psWlc1ZllubDBaWE1wWFFvZ0lDQWdJQ0FnSUdWdVkyaGhiblJsWkY5aWVYUmxJRDBnWW5sMFpWOTJZV3gxWlNCZUlHZHlaV1Z1WDJKNWRHVUtJQ0FnSUNBZ0lDQmxibU5vWVc1MFpXUmZZbmwwWlhNdVlYQndaVzVrS0dWdVkyaGhiblJsWkY5aWVYUmxLUW9nSUNBZ0NpQWdJQ0J5WlhSMWNtNGdaVzVqYUdGdWRHVmtYMko1ZEdWekNnb0taR1ZtSUY5bGJtTnZaR1ZmZEc5ZllXeHNiM2RsWkY5amFHRnljeWgyWVd4MVpYTXBPZ29nSUNBZ1FVeE1UMWRGUkY5RFNFRlNVeUE5SUNKQlFrTkVSVVpIU0VwTFRFMU9VRkZTVTFSVlZsZFlXVm95TXpRMU5qYzRPU0lLSUNBZ0lBb2dJQ0FnSXlCTllYQWdaV0ZqYUNCaWVYUmxJSFpoYkhWbElIUnZJR0ZzYkc5M1pXUWdZMmhoY21GamRHVnlJSE5sZEFvZ0lDQWdaVzVqYjJSbFpGOWphR0Z5Y3lBOUlGdGRDaUFnSUNCbWIzSWdZbmwwWlY5MllXd2dhVzRnZG1Gc2RXVnpPZ29nSUNBZ0lDQWdJR05vWVhKZmFXNWtaWGdnUFNCaWVYUmxYM1poYkNBbElHeGxiaWhCVEV4UFYwVkVYME5JUVZKVEtRb2dJQ0FnSUNBZ0lHVnVZMjlrWldSZlkyaGhjbk11WVhCd1pXNWtLRUZNVEU5WFJVUmZRMGhCVWxOYlkyaGhjbDlwYm1SbGVGMHBDaUFnSUNBS0lDQWdJQ01nVkdGclpTQmxlR0ZqZEd4NUlEUWdZMmhoY21GamRHVnljeUJtYjNJZ2RHaGxJR1pwYm1Gc0lHTnZaR1VLSUNBZ0lISmxkSFZ5YmlBbkp5NXFiMmx1S0dWdVkyOWtaV1JmWTJoaGNuTmJPalJkS1FvS2FXWWdYMTl1WVcxbFgxOGdQVDBnSWw5ZmJXRnBibDlmSWpvS0lDQWdJSEJ5YVc1MEtHZGxibVZ5WVhSbFgyTnZaR1VvTWpBeE1EVTNOalExT1RrMU5qSTRNREFwS1E9PQo=
# SHOPPY Cipher

# Shoppy needs to generate unique discount codes for products at the merchant guild's bazaar. 
# Since the guild's record-keeping system is ancient, they can't store thousands of discount codes. 
# Instead, Shoppy has invented the **SHOPPY Cipher** - a deterministic algorithm that always produces 
# the same discount code for a given product!

ALLOWED_CHARS = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"  # 32 chars, no I/O/0/1
SHOPIFY_GREEN_BYTES = [0x96, 0xBF, 0x48]  # #96BF48

def generate_code(product_id: int) -> str:
    """
    Generate a discount code using the SHOPPY Cipher.
    
    Args:
        product_id: A positive integer
    
    Returns:
        A string in format "SAVE-XXXX" where XXXX uses only allowed characters
    """
    # Step 1: EXPAND - Convert to string and pad with leading zeros to at least 4 digits
    expanded = str(product_id).zfill(4)
    
    # Step 2: CHOP & ROTATE
    chopped = _chop(expanded)
    rotated = _rotate(chopped)
    
    # Step 3: ENCHANT - XOR with Shopify's green hex bytes
    enchanted = _enchant(rotated)
    
    # Step 4: ENCODE - Map to allowed characters
    code = _encode_to_allowed_chars(enchanted)
    return f"SAVE-{code}"

def _chop(product_id_str: str):
    """Split into 2-character chunks."""
    return [product_id_str[i:i+2] for i in range(0, len(product_id_str), 2)]

def _rotate(chunks):
    """Rotate each chunk right by its 1-based index."""
    rotated_parts = []
    for idx, ch in enumerate(chunks, start=1):
        if len(ch) < 2:
            rotated_parts.append(ch)
            continue
        k = idx % len(ch)
        rotated_parts.append(ch[-k:] + ch[:-k] if k else ch)
    return "".join(rotated_parts)

def _enchant(rotated: str):
    """XOR each character with cycling Shopify green bytes."""
    enchanted_bytes = []
    for i, char in enumerate(rotated):
        byte_value = ord(char)
        green_byte = SHOPIFY_GREEN_BYTES[i % len(SHOPIFY_GREEN_BYTES)]
        enchanted_bytes.append(byte_value ^ green_byte)
    return enchanted_bytes

def _encode_to_allowed_chars(values):
    """Map bytes to allowed character set and take first 4 chars."""
    encoded_chars = []
    for byte_val in values:
        char_index = byte_val % len(ALLOWED_CHARS)
        encoded_chars.append(ALLOWED_CHARS[char_index])
    return ''.join(encoded_chars[:4])
